
## grid_across will be read in and saved into global struct and not emptied when other vars are reset
grid_across = {1:{1:0},
2:{1:0},
3:{1:0},
4:{1:0},
5:{1:0},
6:{1:0},
7:{1:0},
8:{1:0},
9:{1:0}
}

## to initialize empty and populate with grid_across. to be emptied and re-populated each iteration
## all 3 grids below to be reset and re-populated with updated grid_across every time values are reset

grid_down = {1:{1:0},
2:{1:0},
3:{1:0},
4:{1:0},
5:{1:0},
6:{1:0},
7:{1:0},
8:{1:0},
9:{1:0}
}

## actual grid block representation:
# grid_block = {z1:{x1:{y1:0, y2:0,y3:0}, x2:{y1:0, y2:0, y3:0}, x3:{y1:0, y2:0, y3:0},
# z2:{x1:{y4:0, y5:0, y6:0}, x2:{y4:0, y5:0, y6:0}, x3:{y4:0, y5:0, y6:0}},
# etc.

grid_block = {1:{1:{1:0, 2:0, 3:0}, 2:{1:0, 2:0, 3:0}, 3:{1:0, 2:0, 3:0}},
2:{1:{4:0, 5:0, 6:0}, 2:{4:0, 5:0, 6:0}, 3:{4:0, 5:0, 6:0}},
3:{1:{7:0, 8:0, 9:0}, 2:{7:0, 8:0, 9:0}, 3:{7:0, 8:0, 9:0}},
4:{4:{1:0, 2:0, 3:0}, 5:{1:0, 2:0, 3:0}, 6:{1:0, 2:0, 3:0}},
5:{4:{4:0, 5:0, 6:0}, 5:{4:0, 5:0, 6:0}, 6:{4:0, 5:0, 6:0}},
6:{4:{7:0, 8:0, 9:0}, 5:{7:0, 8:0, 9:0}, 6:{7:0, 8:0, 9:0}},
7:{7:{1:0, 2:0, 3:0}, 8:{1:0, 2:0, 3:0}, 9:{1:0, 2:0, 3:0}},
8:{7:{4:0, 5:0, 6:0}, 8:{4:0, 5:0, 6:0}, 9:{4:0, 5:0, 6:0}},
9:{7:{7:0, 8:0, 9:0}, 8:{7:0, 8:0, 9:0}, 9:{7:0, 8:0, 9:0}}}


changes_cnt = 0
x1 = 1
y1 = 1
x2 = 1
y2 = 1
z2 = 1 # set this for block number based on x2 y2 values

#keeps track of how many numbers found and pops completed numbers from dict -- in future anyway...
nr_counts = {1:0, 2:0, 3:0, 4:0, 5:0, 6:0, 7:0, 8:0, 9:0}


# keeps track of all possible numbers for that position
# first pop out all completed items, so that only open spaces in here
grid_across_possible = {1:{1:[], 2:[], 3:[], 4:[], 5:[], 6:[], 7:[], 8:[], 9:[]}, 
2:{1:[], 2:[], 3:[], 4:[], 5:[], 6:[], 7:[], 8:[], 9:[]}, 
3:{1:[], 2:[], 3:[], 4:[], 5:[], 6:[], 7:[], 8:[], 9:[]}, 
4:{1:[], 2:[], 3:[], 4:[], 5:[], 6:[], 7:[], 8:[], 9:[]},
5:{1:[], 2:[], 3:[], 4:[], 5:[], 6:[], 7:[], 8:[], 9:[]},
6:{1:[], 2:[], 3:[], 4:[], 5:[], 6:[], 7:[], 8:[], 9:[]},
7:{1:[], 2:[], 3:[], 4:[], 5:[], 6:[], 7:[], 8:[], 9:[]},
8:{1:[], 2:[], 3:[], 4:[], 5:[], 6:[], 7:[], 8:[], 9:[]},
9:{1:[], 2:[], 3:[], 4:[], 5:[], 6:[], 7:[], 8:[], 9:[]}
}

# to apply logic: if only one possible value in a block, that's the value.
grid_block_possible = {1:{1:{1:[], 2:[], 3:[]}, 2:{1:[], 2:[], 3:[]}, 3:{1:[], 2:[], 3:[]}},
2:{1:{4:[], 5:[], 6:[]}, 2:{4:[], 5:[], 6:[]}, 3:{4:[], 5:[], 6:[]}},
3:{1:{7:[], 8:[], 9:[]}, 2:{7:[], 8:[], 9:[]}, 3:{7:[], 8:[], 9:[]}},
4:{4:{1:[], 2:[], 3:[]}, 5:{1:[], 2:[], 3:[]}, 6:{1:[], 2:[], 3:[]}},
5:{4:{4:[], 5:[], 6:[]}, 5:{4:[], 5:[], 6:[]}, 6:{4:[], 5:[], 6:[]}},
6:{4:{7:[], 8:[], 9:[]}, 5:{7:[], 8:[], 9:[]}, 6:{7:[], 8:[], 9:[]}},
7:{7:{1:[], 2:[], 3:[]}, 8:{1:[], 2:[], 3:[]}, 9:{1:[], 2:[], 3:[]}},
8:{7:{4:[], 5:[], 6:[]}, 8:{4:[], 5:[], 6:[]}, 9:{4:[], 5:[], 6:[]}},
9:{7:{7:[], 8:[], 9:[]}, 8:{7:[], 8:[], 9:[]}, 9:{7:[], 8:[], 9:[]}}}
